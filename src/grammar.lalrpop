use std::str::FromStr;
use crate::parser::{Node, Operator};

grammar;

pub Node: Box<Node> = {
    Block => Box::new(Node::Block(<>)),
    <s:Statement> => s,
}

Term: Box<Node> = {
    <Num> => Box::new(Node::NumLiteral(<>)),
    <EmStr> => Box::new(Node::StrLiteral(<>)),
    <EmBool> => Box::new(Node::BoolLiteral(<>)),
    Name,
    "(" <Expr> ")",
}

Statement: Box<Node> = {
    <Name> <Tuple> ";" => Box::new(Node::Call(<>)),
    FN <Name> <Tuple> <Block> => Box::new(Node::Func(<>)),
    <n:Name> "=" <e:Expr> ";" => Box::new(Node::Operation(n, Operator::Equals, e)),
}

Expr: Box<Node> = {
    <f:Expr> "+" <e:Factor> => Box::new(Node::Operation(f, Operator::Add, e)),
    <f:Expr> "-" <e:Factor> => Box::new(Node::Operation(f, Operator::Sub, e)),
    Factor
}

Factor: Box<Node> = {
    <f:Factor> "*" <e:Term> => Box::new(Node::Operation(f, Operator::Mul, e)),
    <f:Factor> "/" <e:Term> => Box::new(Node::Operation(f, Operator::Div, e)),
    Term

}


Block: Vec<Box<Node>> = "{" <Node+> "}" => Vec::from(<>);
Tuple: Vec<Box<Node>> = <c:("(" <Comma<Expr>> ")")> => c;

//--primitives--//
Num: f32 = <n:r"[0-9]+"> => f32::from_str(n).unwrap();
EmStr: String =  <s:(r#"""# <r#"[.^"]+"#> r#"""#)>  => format!("{}", s);
EmBool: bool = {
    <t:r"true"> => true,
    <f:r"false"> => false
}

Name: Box<Node> = <n:r"[A-Za-z]\w*"> => Box::new(Node::Name(format!("{}", n)));

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    } 
};

//--keywords--//
match{
    r#"""#,
    "true",
    "false",
    "fn" => FN,
    "new" => NEW,
    r"\s*" => { }, // The default whitespace skipping is disabled an `ignore pattern` is specified
    r"//[^\n\r]*[\n\r]*" => { }, // Skip `// comments`
    r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/" => { },  // Skip `/* comments */`
}else {
    _
}
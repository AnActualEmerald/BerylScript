use std::str::FromStr;
use crate::parser::{Node, Operator};

grammar;

pub Node: Box<Node> = {
    Block => Box::new(Node::Block(<>)),
    <s:Statement> => s,
}

Term: Box<Node> = {
    <Num> => Box::new(Node::NumLiteral(<>)),
    <EmStr> => Box::new(Node::StrLiteral(<>)),
    <EmBool> => Box::new(Node::BoolLiteral(<>)),
    <List> => Box::new(Node::Array(<>)),
    <Name> <Tuple> => Box::new(Node::Call(<>)),
    <Name> <Index> => Box::new(Node::Index(<>)),
    "new" <Name> <Tuple> => Box::new(Node::New(<>)),
    Name,
    "(" <Expr> ")",
}

Statement: Box<Node> = {
    "fn" <Name> <Tuple> <Block> => Box::new(Node::Func(<>)),
    "class" <n:Name> <b:Block> => Box::new(Node::Class(n, Box::new(Node::Block(b)))),
    "return" <Expr> ";" => Box::new(Node::ReturnVal(<>)),
    <Expr> ";",
}

Expr: Box<Node> = {
    <f:Expr> "+" <e:Factor> => Box::new(Node::Operation(f, Operator::Add, e)),
    <f:Expr> "-" <e:Factor> => Box::new(Node::Operation(f, Operator::Sub, e)),
    <n:Assignable> "=" <e:Factor> => Box::new(Node::Operation(n, Operator::Equals, e)),
    <f:Expr> "==" <e:Factor> => Box::new(Node::Operation(f, Operator::EqualTo, e)),
    <f:Expr> "!=" <e:Factor> => Box::new(Node::Operation(f, Operator::NotEqualTo, e)),
    <f:Expr> ">" <e:Factor> => Box::new(Node::Operation(f, Operator::Greater, e)),
    <f:Expr> "<" <e:Factor> => Box::new(Node::Operation(f, Operator::Less, e)),
    <f:Expr> ">=" <e:Factor> => Box::new(Node::Operation(f, Operator::GreaterOrEq, e)),
    <f:Expr> "<=" <e:Factor> => Box::new(Node::Operation(f, Operator::LessOrEq, e)),
    Factor
}

Factor: Box<Node> = {
    <f:Factor> "*" <e:Term> => Box::new(Node::Operation(f, Operator::Mul, e)),
    <f:Factor> "/" <e:Term> => Box::new(Node::Operation(f, Operator::Div, e)),
    <n:Name> "." <e:Term> => Box::new(Node::Operation(n, Operator::Dot, e)),
    Term

}

Assignable: Box<Node> = {
    <n:Name> "." <e:Term> => Box::new(Node::Operation(n, Operator::Dot, e)),
    Name,
    <Name> <Index> => Box::new(Node::Index(<>)),
}

// //--Special rules for making class definitions--//
// Method: Box<Node> = <Name> <Tuple> <Block> =>  Box::new(Node::Func(<>));
// ClassBody: Box<Node> = "{" <Method+> "}" => Box::new(Node::Block(<>));

//--Different ways to group Nodes--//
Block: Vec<Box<Node>> = "{" <Node*> "}" => Vec::from(<>);
Tuple: Vec<Box<Node>> = <c:("(" <Comma<Expr>> ")")> => c;
Index: Box<Node> = "[" <Expr> "]" => <>;
List: Vec<Box<Node>> = "[" <Comma<Expr>> "]" => <>;

//--primitives--//
Num: f32 = <n:r"[0-9]+"> => f32::from_str(n).unwrap();
// I cannot for the life of me figure out how to make it match the quotes exclusively
EmStr: String = <s:r#""[^"]*""#> => s.strip_prefix('"').unwrap().strip_suffix('"').unwrap().to_string();
EmBool: bool = {
    <t:r"true"> => true,
    <f:r"false"> => false
}

Name: Box<Node> = <n:r"[A-Za-z~][A-Za-z0-9]+"> => Box::new(Node::Name(format!("{}", n)));

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    } 
};

//--keywords--//
match{
    "true",
    "false",
    "class",
    "fn",
    "new",
    "return",
    r"\s*" => { }, // The default whitespace skipping is disabled an `ignore pattern` is specified
    r"//[^\n\r]*[\n\r]*" => { }, // Skip `// comments`
    r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/" => { },  // Skip `/* comments */`
}else {
    _
}